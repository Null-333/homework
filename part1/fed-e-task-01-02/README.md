# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```
执行结果是10
函数中打印的i不是这个函数的局部作用域中的变量，而是ECG中的变量，在循环执行结束后，这个变量已经是10，所以打印出来时10

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```
只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响
let不会变量提升，所以直接报错

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
console.log(Math.min(...arr));
```

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别
var 会变量提升
let 不会变量提升，并且let存在块级作用域，用let声明的变量，在块级作用域以外无法访问。
const 声明的是一个只读的变量，对于对象来说，常量不能修改内存地址，但是可以修改对象中的元素。

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
结果是20，因为箭头函数不会改变this的指向，这里的this其实是调用fn的时候this的指向
　
### 6. 简述Symbol类型的用途
Symbol可以解决属性名冲突的问题，很多时候我们在使用第三方模块的时候需要对第三方模块进行扩展，
这个时候如果使用一般字符串类型的key，就可能会引起属性名的冲突，而Symbol也可以作为对象的属性名，
并且每次创建都是不同的，这样就可以解决属性名冲突的问题
　
### 7. 说说什么是浅拷贝，什么是深拷贝？
浅拷贝就是指对象复制的时候只复制一层;深拷贝是指复制对象的所有层级
　
### 8. 请简述TypeScript与JavaScript之间的关系？
TypeScript是JavaScript的超集
TypeScript在JavaScript基础上多出来一些特性：类型声明和ES6+的支持
TypeScript最终会被编译成JavaScript

### 9. 请谈谈你所认为的typescript优缺点
优点：
TypeScript可以支持类型声明
TypeScript可以编译ES6+的语法
TypeScript的开发工具支持很流畅（vscode）
对于长周期的大项目更好维护
渐进式的

缺点：
对于小项目来说，typescript会不太灵活，增加编码成本
有一定的学习成本

　

### 10. 描述引用计数的工作原理和优缺点
优点：
发现垃圾立即回收
最大程度的减少程序暂停

缺点：
不能清除掉循环引用的对象
时间开销大（因为他自己会维护一个引用计数器，时刻监控引用计数的值）

### 11. 描述标记整理算法的工作流程
1. 遍历所有活动对象，做标记
2. 将活动对象整理成一个连续的地址
3. 然后将活动对象右侧（就是指不活动的对象）的位置做一个整体的回收

### 12.描述V8中新生代存储区垃圾回收的流程
新生代区域存放一些存活时间较短的对象
新生代区域分为两个区域：from和to
小空间用于存储新生代对象

刚开始使用from空间，空闲空间是to
from用来存放活动对象
当进行了标记整理算法后，在from空间中活动对象的地址连续，
然后将活动对象拷贝到to
然后将from的空间完全的释放掉，让from和to空间进行一个交换
回收的细节：
在拷贝的过程中，可能会将新生代区域中的对象晋升到老生带
晋升条件：
1. 在一次GC后，仍然存活的对象
2. 当to区域的空间使用达到25%
### 13. 描述增量标记算法在何时使用及工作原理
当新生代向老生带晋升，并且，老生带空间不足时，则进行标记整理

1.JS程序执行过程中，会伴随着垃圾回收的工作。
2.当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，标记完成后暂停标记
3.然后让JS程序执行一会，再让GC机制去做二步标记，将间接可达的对象进行标记，标记完成后暂停标记。
4.重复以上两不操作，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的。
5.直到标记全部完成后，执行垃圾回收